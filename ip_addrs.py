'''
Andre' Coryea-Robinson
5 October 2022

Library of funtions to handle IPv4 addresses
This library is made by a bored, sleepy 24-year-old American in his free time.
As such, it probably shouldn't be used by anyone. Someone has probably done
this already anyways, but I thought I'd learn from doing it myself.
'''

_MAX_MASK = (1<<32) - 1

def dotted_to_int(ip_text):
    '''
    Converts a dotted decimal ipv4 address (string) to an integer.
    For example, "1.2.3.4" becomes 16909060
    The input should be a valid ipv4 address in dotted decimal format.
    '''
    # Extract the ip address into four integers, each representing an octet
    octet_strings = ip_text.split('.')
    octet_ints = [int(octet) for octet in octet_strings]

    # Use bit arithmetic to create a single int from this
    octet_ints = [octet_ints[i] << (8 * (3-i)) for i in range(4)]
    ip_int = 0
    for octet in octet_ints:
        # bit manipulation is typically faster than integer math
        ip_int = ip_int | octet
    return ip_int
    

def int_to_dotted(ip_int):
    '''
    Converts an integer ip_int to a dotted decimal ipv4 address.
    For example, 16909060 becomes "1.2.3.4"
    requires 0 <= ip_int < 2**32
    '''
    # First use bit arithmetic to create a list of four ints
    # Each representing an octet in the IPv4 address
    # Explanation: octet_ints[i] is generated by right shifting
    # ip_int by the proper amount and then using a bit mask to extract
    # the relevant field (the least significant 8 bits at this point)
    octet_ints = [255 & (ip_int >> i * 8) for i in range(3,-1,-1)]

    # Use this list of ints to genrate a string
    octet_strings = [str(octet) for octet in octet_ints]
    ip_text = '.'.join(octet_strings)
    return ip_text

def get_subnet_id(ip_int, subnet_mask_int):
    '''
    Given an IPv4 address (ip_int) and a subnet mask (subnet_mask_int),
    generate the subnet ID.
    For example, given ip_int 3232235808 and subnet_mask_int 4294967040,
    returns 3232235776
    requires:
        0 <= ip_int < 2**32
        subnet_mask_int = (2**32 - 1) - (2**C - 1) | 0 < C <= 32
            (Subnet mask should representable as a 32-bit binary number
            generated by (2^n-1) bitshifted left until the MSB is 1.
            In other words, it should be a valid IPv4 subnet mask.)
    '''
    return subnet_mask_int & ip_int

def get_wildcard_mask(subnet_mask_int):
    '''
        Given a subnet mask, generates the wildcard mask
        requires:
        subnet_mask_int = (2**32 - 1) - (2**C - 1) | 0 < C <= 32
            (Subnet mask should representable as a 32-bit binary number
            generated by (2^n-1) bitshifted left until the MSB is 1.
            In other words, it should be a valid IPv4 subnet mask.)
    '''
    return _MAX_MASK ^ subnet_mask_int

def get_wildcard_address(ip_int, subnet_mask_int):
    '''
        Given an IPv4 address (ip_int) and a subnet mask (subnet_mask_int),
        generate the wildcard address for the subnet which contains ip_int
        described by the subnet mask subnet_mask_int.
        requires:
        0 <= ip_int < 2**32
        subnet_mask_int = (2**32 - 1) - (2**C - 1) | 0 < C <= 32
            (Subnet mask should representable as a 32-bit binary number
            generated by (2^n-1) bitshifted left until the MSB is 1.
            In other words, it should be a valid IPv4 subnet mask.)
    '''
    wildcard_mask_int = get_wildcard_mask(subnet_mask_int)
    subnet_id = get_subnet_id(ip_int, subnet_mask_int)
    return (subnet_id | wildcard_mask_int)

def count_usable_addresses(subnet_mask_int):
    '''
        Return the number of usable IPv4 addresses in a subnet described by
        subnet_mask_int, assuming network_id and broadcast address are unusable
        requires:
        subnet_mask_int = (2**32 - 1) - (2**C - 1) | 0 < C <= 32
            (Subnet mask should representable as a 32-bit binary number
            generated by (2^n-1) bitshifted left until the MSB is 1.
            In other words, it should be a valid IPv4 subnet mask.)
    '''
    return get_wildcard_mask(subnet_mask_int)

